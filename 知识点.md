# 代码可读性
在代码中硬编码数字（如直接写 `40`）被称为“魔法数字”（magic number）。这种做法让代码可读性降低，因为其他开发者可能不知道 `40` 的意义。而 `sizeof(c)` 直接反映了数组大小，使代码更清晰



# 结构体
## typedef
### 用法:
`typedef`可以为类型定义==别名==，但它并不允许直接在声明时创建实例。`typedef`用于定义类型，但它不能同时用于创建变量或实例。你可以先定义一个结构体类型，然后再创建实例

> 
#### 1. 结构体类型的 `typedef`

通常，`typedef` 后面紧跟着结构体的定义体，然后再给结构体类型命名。

注意大括号前and后
```c
typedef struct {     char kemu[100];     
				int num; 
				} Subject;  // 结构体类型的别名 Subject`
```
此时是匿名的结构体,直接给他来了个别名

或者
```c
```typedef struct Subject {     char kemu[100];     
						   int num; } Subject;  // 结构体类型的别名 Subject
```
这种写法显式命名了结构体名称

#### 2. 不一定需要在大括号后面

你还可以在结构体定义外部定义类型别名，这样可以在结构体定义后使用：

```c
struct Subject {     char kemu[100];     int num; };  typedef struct Subject SubjectAlias;  // 使用 typedef 创建别名
```
这里，`typedef` 并不紧接在结构体定义的后面，而是分开写的。


>   struct Person   person是类型名
    int person   person是变量名

编译器默认变量声明上下文
	为了不冲突,默认单独出现的就是变量名了,加个struct就是类型名
`typedef`为类型创建了别名，把原本属于`struct`命名空间的名字直接放入==普通的类型==命名空间中，从而可以省略`struct`关键字.
使用 `typedef` 后，给结构体起了一个新名字，这个新名字被放入了普通的类型命名空间（即==与 `int`、`float` 等内置类型同属一个空间==），所以不再需要使用 `struct` 来引用它
>struct Person p1; // 声明变量 p1.age = 20
 实例p1作为一个普通变量,可以单独使用

## 结构体访问成员

    通过结构体实例：使用点运算符（.）来访问成员。  
    通过结构体指针：使用箭头运算符（->）来访问成员。
即使在没有显式声明某个结构体实例的情况下，你依然可以通过数组索引访问结构体实例的成员

==->== 运算符是 解引用指针并访问成员 的简写，它结合了 解引用 和 成员访问 两个操作.就是解应用得到原对象再访问

## 结构体交换

```c
Subject temp = s[j]; // Swap the structures s[j] = s[j + 1]; 
s[j + 1] = temp;
```
你使用的交换方法是通过值复制来交换两个结构体变量，所以整个结构体的内容（包括所有成员）都会被交换。

在C语言中，结构体是值传递类型，因此，当你交换结构体时，实际上是在交换结构体的副本

# 数组
## 字符数组
注意,最多读取n-1个,要记得留一个位置给\0

```c
char name[50]; // 定义字符数组，用来存储输入的字符串 printf("Enter your name: "); scanf("%s", name); // 使用 scanf 读取字符串输入 printf("Hello, %s!\n", name); // 输出输入的字符串
```
可以直接使用%s输入和输出,不过要赋值只能用strcpy

### 字符数组输入
其中当然可以有空格,只是scanf识别到空格就停下了,而gets不会停下
可以存空格,但存的媒介要考虑清楚
#### gets和fgets


`gets` 函数的参数应该是一个字符数组，而不是单个字符变量 `c`。所以，`gets(c);` 是错误的，正确的用法是直接用 `scanf` 或初始化数组来获取单个字符。
```c
统计字符串中字母、数字、空格和其他字符的个数。

### 输入格式:

在一行中输入长度不超过40的字符串。

### 输出格式:

第一行中输出“zimu=x“

第二行中输出“shuzi=y“

第三行中输出“kongge=z”，

第四行中输出“qita=m”
#include <stdio.h>
#include <string.h>

int main() {
    char c[40];
    fgets(c, sizeof(c), stdin);  // 使用fgets代替gets，避免缓冲区溢出

    int i, zimu = 0, shuzi = 0, kongge = 0, m = 0;

    // 获取字符串的有效长度，避免处理多余的字符
    int len = strlen(c);
    
    for (i = 0; i < len; i++) {
        if ((c[i] >= 'A' && c[i] <= 'Z') || (c[i] >= 'a' && c[i] <= 'z')) {
            zimu++;
        } else if (c[i] >= '0' && c[i] <= '9') {
            shuzi++;
        } else if (c[i] == ' ') {
            kongge++;
        } else {
            m++;
        }
    }

    // 输出结果
    printf("zimu=%d\n", zimu);
    printf("shuzi=%d\n", shuzi);
    printf("kongge=%d\n", kongge);
    printf("qita=%d\n", m);

    return 0;
}

```
gets会将没满的部分乱填充
- fgets
- **输入未满 39 字符：** 如果用户输入的字符少于 39（比如输入 `Hello` 后按下 `Enter`），那么 `fgets` 会读取：
    
    - 5 个字符 `Hello`
    - 1 个换行符 ==`\n`==
    - 1 个空字符 `\0`
    
    最终数组 `c` 的内容是：`{'H', 'e', 'l', 'l', 'o', '\n', '\0'}`。
    
- **输入超过 39 字符：** 例如输入 `This is a very long string that exceeds the limit`，`fgets` 会读取：
    
    - 前 39 个字符 `This is a very long string that exceed`
    - 1 个空字符 `\0`。
    
    剩余的字符 `s the limit` 保留在缓冲区中，可以通过后续调用 `fgets` 再次读取。
>fgets相当于数据去覆盖数组
如果输入字符少于 39 个，数组中未被覆盖的部分不会被 `fgets` 修改，它们的值取决于数组在内存中的初始状态，可能是随机的未定义数据
字符数组只有在初始化时，如果没有填满，剩余的部分才会自动填充为 `\0`

fgets(c,40,stdin);
    int len=strlen(c);
    int i,zimu=0,shuzi=0,kongge=0,m=0;
    for(i=0;i<len;i++)
所以如果没有==初始化数组==,那就要把循环长度控制在有效长度
不行,必须要限制为strlen,不然<40,后面自动填充的会被识别到,除非再写一个if判断
> 此题最重要的就是控制识别长度
> 控制了之后,就不用管你不满足的地方了,gets和fgets都是可以的


&&使用 `fgets()` 代替 `gets()`，它会限制输入的最大长度，并且可以有效防止溢出。同时，可以确保未使用的部分不被误认为有效字符

fgets会读取换行符,gets不会
去掉int len = 0; while (arr[len] != '\0' && arr[len] != '\n') { len++; } arr[len] = '\0';



### **数组越界问题**

`for (i = 0; i < 80; i++)` 遍历整个数组，但 `gets` 函数只读取一行输入，并用 `\0` 标记结束。因此，当 `arr[i]` 到达未被输入的数据区域时，可能会造成未定义行为。

修正方法： 使用输入的字符串长度作为循环的条件：
#for条件
for里面写的是能进行循环要满足的条件

```c
for (i = 0; arr[i] != '\0'; i++)`
```

"段错误"（Segmentation Fault，简称 "segfault"）是指程序访问了操作系统不允许访问的内存区域
越界,free*2

在C语言中，`fgets()` 和 `scanf()` 都会读取输入缓冲区的数据。当你调用 `fgets()` 读取一行输入时，它会将输入的数据（包括换行符 `\n`）存储在缓冲区中。如果输入的字符串长度小于指定的长度，剩余的部分就会被填充，换行符会保留在缓冲区。

当你接着调用 `scanf("%c")` 时，它会从缓冲区中读取字符。因为换行符还在缓冲区中，所以 `scanf` 会把这个换行符当作输入字符读取，导致意外的行为。这就可能是你遇到段错误或不预期结果的原因。

为了避免这个问题，通常我们会在读取字符之前清空输入缓冲区或者使用适当的输入方式，例如：

- 在 `fgets()` 之后，使用 `getchar()` 来读取并丢弃缓冲区中的换行符，确保下一次输入是新的数据。
- 使用 `scanf(" %c")`（注意前面的空格）来跳过任何前导空白字符，包括换行符。

# argv
是的，`char *arr[]` 在声明时通常需要指定数组的**元素个数**，特别是当你在声明一个字符指针数组时。让我们更详细地解释一下。

### **`char *arr[]` 声明的含义**

在声明 `char *arr[]` 时，`arr` 是一个字符指针数组。每个数组元素都是一个指向字符类型的指针 (`char *`)。

例如：

```c
char *arr[] = {"Hello", "World", "!"};
```

这里，`arr` 是一个字符指针数组，包含了 3 个元素。每个元素都是一个指向字符串的指针。

### **是否需要指定元素个数**

- **初始化时可以省略元素个数**：当你为数组提供了初始化列表时，编译器会自动推断数组的大小。例如：
    
    ```c
    char *arr[] = {"Hello", "World", "!"};
    ```
    
    在这种情况下，编译器会自动计算出数组有 3 个元素，并为 `arr` 分配相应大小的内存。因此，在初始化时，你不需要显式地指定数组的大小。
    
- **声明时需要指定大小**：如果你没有提供初始化列表，那么你必须显式地指定数组的元素个数。例如：
    
    ```c
    char *arr[3];  // 声明一个包含 3 个字符指针的数组
    ```
    
    在这种情况下，数组 `arr` 有 3 个元素，每个元素是一个 `char *` 类型的指针。
    

### **为什么要指定大小**

在 C 语言中，数组的大小是必须在编译时确定的。对于字符指针数组，虽然每个元素是一个指针，指针的大小是固定的，但我们需要指定数组元素的个数，以便编译器知道为这些指针分配多少内存。

- 如果你提供了初始化列表，编译器会根据列表中的元素自动推断出数组的大小。
- 如果没有初始化列表，编译器无法自动推断数组的大小，因此你必须显式地指定。

### **总结**

- **初始化时**，`char *arr[]` 可以不显式指定大小，编译器会根据初始化内容推断出元素的个数。
- **声明时**，如果没有初始化内容，必须显式指定数组的大小（如 `char *arr[3]`）。

argv是因为,我们有初始化它,应该就是程序传参吧
### **1. 数组与指针的基础概念**

首先，让我们理清数组和指针的基本概念：

- **数组**：一个数组是**连续存储的**内存块，数组内的元素是数据（例如：`int`、`char` 等），并且数组在声明时需要知道它包含多少个元素。数组的大小在声明时必须确定，因为它涉及到内存的分配和访问方式。
    
- **指针**：指针是一个**存储地址**的变量，它指向某个特定数据的位置。指针本身只需要存储一个地址（内存中的位置），所以指针的大小通常是固定的。指针大小通常是 4 字节（在 32 位系统上）或 8 字节（在 64 位系统上）。


#### **1. 在函数参数中使用普通数组时**

在函数参数中，数组的大小不能像局部数组一样自动推断出来。C 语言中，数组作为函数参数传递时，通常会被“退化”成指针，因此我们必须显式传递数组的大小。

例如：

c

复制代码

`void printArray(int arr[], int size) {     for (int i = 0; i < size; i++) {         printf("%d ", arr[i]);     } }`

在这里，`arr[]` 被视为一个指针，编译器不知道数组的实际大小，因此我们必须通过额外的 `size` 参数来告诉函数数组的大小。


是的，Emma，你理解得非常对！当你在 `main` 函数中使用 `char *arr[]` 来接收命令行参数时，确实不需要显式指定数组的大小，因为数组的大小是由传入的参数数量决定的，编译器会根据传入的参数自动推断。

### **`char *arr[]` 和 `main` 函数中的命令行参数**

在 `main` 函数中，`char *arr[]` 经常用于接收命令行参数。这里的 `arr` 是一个字符指针数组，其中每个元素是一个指向字符数组（即字符串）的指针。

常见的 `main` 函数定义是：

```c
int main(int argc, char *argv[])
```

- **`argc`**：表示命令行参数的数量，包括程序本身的名称。
- **`argv[]`**：是一个指向字符指针的数组，数组中的每个元素都是一个指向字符串的指针，这些字符串分别对应命令行中的各个参数。

### **为什么 `char *arr[]` 不需要指定大小**,因为已经有argc了!!

在 `main` 函数中，`argv[]` 数组的大小是由命令行传入的参数数量决定的，而不是固定的。在运行程序时，操作系统会将命令行参数传递给程序，并且会自动将这些参数存储在 `argv[]` 中。

例如：

```bash
./my_program arg1 arg2 arg3
```

当你运行这个命令时，操作系统会将 `"./my_program"`, `"arg1"`, `"arg2"`, `"arg3"` 作为命令行参数传递给程序，`argc` 会被设置为 4（因为有 4 个参数），而 `argv` 会是一个包含 4 个元素的数组。

具体到代码：

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    // argc 是传入参数的个数
    // argv 是一个字符指针数组，存储了每个参数的字符串
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }
    return 0;
}
```

在这种情况下，**`argv[]` 的大小由操作系统根据命令行参数的数量自动确定**，你不需要手动指定。

### **自动推断的原理**

在程序启动时，操作系统会根据传递给程序的参数个数来为 `argv[]` 分配内存。所以你不需要提前知道数组的大小，`argv[]` 会自动根据传入的命令行参数进行初始化，数组的每个元素都是一个指向字符串的指针。

### **总结**

- 在 `main` 函数中，`char *arr[]`（实际上是 `argv[]`）的大小是由程序启动时传入的命令行参数数量来决定的，因此不需要显式指定数组的大小。
- `argc` 给出了命令行参数的个数，而 `argv[]` 中存储的是这些参数的字符串。


# 目录
`DIR`是一个在C语言中定义的结构体类型，代表一个目录流。它在`<dirent.h>`头文件中被声明，用于存储与目录相关的信息，比如目录中每个文件或子目录的名称。

### `DIR`和`struct dirent`的关系

- `DIR`代表一个打开的目录流，它本身并不直接包含目录项，而是一个“连接”到目录的对象。
- `struct dirent`是描述单个目录项的结构，包含文件名和其他信息（如文件类型）。