# 代码可读性
在代码中硬编码数字（如直接写 `40`）被称为“魔法数字”（magic number）。这种做法让代码可读性降低，因为其他开发者可能不知道 `40` 的意义。而 `sizeof(c)` 直接反映了数组大小，使代码更清晰



# 结构体
## typedef
### 用法:
`typedef`可以为类型定义==别名==，但它并不允许直接在声明时创建实例。`typedef`用于定义类型，但它不能同时用于创建变量或实例。你可以先定义一个结构体类型，然后再创建实例

> 
#### 1. 结构体类型的 `typedef`

通常，`typedef` 后面紧跟着结构体的定义体，然后再给结构体类型命名。

注意大括号前and后
```c
typedef struct {     char kemu[100];     
				int num; 
				} Subject;  // 结构体类型的别名 Subject`
```
此时是匿名的结构体,直接给他来了个别名

或者
```c
```typedef struct Subject {     char kemu[100];     
						   int num; } Subject;  // 结构体类型的别名 Subject
```
这种写法显式命名了结构体名称

#### 2. 不一定需要在大括号后面

你还可以在结构体定义外部定义类型别名，这样可以在结构体定义后使用：

```c
struct Subject {     char kemu[100];     int num; };  typedef struct Subject SubjectAlias;  // 使用 typedef 创建别名
```
这里，`typedef` 并不紧接在结构体定义的后面，而是分开写的。


>   struct Person   person是类型名
    int person   person是变量名

编译器默认变量声明上下文
	为了不冲突,默认单独出现的就是变量名了,加个struct就是类型名
`typedef`为类型创建了别名，把原本属于`struct`命名空间的名字直接放入==普通的类型==命名空间中，从而可以省略`struct`关键字.
使用 `typedef` 后，给结构体起了一个新名字，这个新名字被放入了普通的类型命名空间（即==与 `int`、`float` 等内置类型同属一个空间==），所以不再需要使用 `struct` 来引用它
>struct Person p1; // 声明变量 p1.age = 20
 实例p1作为一个普通变量,可以单独使用

## 结构体访问成员

    通过结构体实例：使用点运算符（.）来访问成员。  
    通过结构体指针：使用箭头运算符（->）来访问成员。
即使在没有显式声明某个结构体实例的情况下，你依然可以通过数组索引访问结构体实例的成员

==->== 运算符是 解引用指针并访问成员 的简写，它结合了 解引用 和 成员访问 两个操作.就是解应用得到原对象再访问

## 结构体交换

```c
Subject temp = s[j]; // Swap the structures s[j] = s[j + 1]; 
s[j + 1] = temp;
```
你使用的交换方法是通过值复制来交换两个结构体变量，所以整个结构体的内容（包括所有成员）都会被交换。

在C语言中，结构体是值传递类型，因此，当你交换结构体时，实际上是在交换结构体的副本

# 数组
## 字符数组
注意,最多读取n-1个,要记得留一个位置给\0

```c
char name[50]; // 定义字符数组，用来存储输入的字符串 printf("Enter your name: "); scanf("%s", name); // 使用 scanf 读取字符串输入 printf("Hello, %s!\n", name); // 输出输入的字符串
```
可以直接使用%s输入和输出,不过要赋值只能用strcpy

### 字符数组输入
其中当然可以有空格,只是scanf识别到空格就停下了,而gets不会停下
可以存空格,但存的媒介要考虑清楚
#### gets和fgets


`gets` 函数的参数应该是一个字符数组，而不是单个字符变量 `c`。所以，`gets(c);` 是错误的，正确的用法是直接用 `scanf` 或初始化数组来获取单个字符。
```c
统计字符串中字母、数字、空格和其他字符的个数。

### 输入格式:

在一行中输入长度不超过40的字符串。

### 输出格式:

第一行中输出“zimu=x“

第二行中输出“shuzi=y“

第三行中输出“kongge=z”，

第四行中输出“qita=m”
#include <stdio.h>
#include <string.h>

int main() {
    char c[40];
    fgets(c, sizeof(c), stdin);  // 使用fgets代替gets，避免缓冲区溢出

    int i, zimu = 0, shuzi = 0, kongge = 0, m = 0;

    // 获取字符串的有效长度，避免处理多余的字符
    int len = strlen(c);
    
    for (i = 0; i < len; i++) {
        if ((c[i] >= 'A' && c[i] <= 'Z') || (c[i] >= 'a' && c[i] <= 'z')) {
            zimu++;
        } else if (c[i] >= '0' && c[i] <= '9') {
            shuzi++;
        } else if (c[i] == ' ') {
            kongge++;
        } else {
            m++;
        }
    }

    // 输出结果
    printf("zimu=%d\n", zimu);
    printf("shuzi=%d\n", shuzi);
    printf("kongge=%d\n", kongge);
    printf("qita=%d\n", m);

    return 0;
}

```
gets会将没满的部分乱填充
- fgets
- **输入未满 39 字符：** 如果用户输入的字符少于 39（比如输入 `Hello` 后按下 `Enter`），那么 `fgets` 会读取：
    
    - 5 个字符 `Hello`
    - 1 个换行符 ==`\n`==
    - 1 个空字符 `\0`
    
    最终数组 `c` 的内容是：`{'H', 'e', 'l', 'l', 'o', '\n', '\0'}`。
    
- **输入超过 39 字符：** 例如输入 `This is a very long string that exceeds the limit`，`fgets` 会读取：
    
    - 前 39 个字符 `This is a very long string that exceed`
    - 1 个空字符 `\0`。
    
    剩余的字符 `s the limit` 保留在缓冲区中，可以通过后续调用 `fgets` 再次读取。
>fgets相当于数据去覆盖数组
如果输入字符少于 39 个，数组中未被覆盖的部分不会被 `fgets` 修改，它们的值取决于数组在内存中的初始状态，可能是随机的未定义数据
字符数组只有在初始化时，如果没有填满，剩余的部分才会自动填充为 `\0`

fgets(c,40,stdin);
    int len=strlen(c);
    int i,zimu=0,shuzi=0,kongge=0,m=0;
    for(i=0;i<len;i++)
所以如果没有==初始化数组==,那就要把循环长度控制在有效长度
不行,必须要限制为strlen,不然<40,后面自动填充的会被识别到,除非再写一个if判断
> 此题最重要的就是控制识别长度
> 控制了之后,就不用管你不满足的地方了,gets和fgets都是可以的


&&使用 `fgets()` 代替 `gets()`，它会限制输入的最大长度，并且可以有效防止溢出。同时，可以确保未使用的部分不被误认为有效字符

fgets会读取换行符,gets不会
去掉int len = 0; while (arr[len] != '\0' && arr[len] != '\n') { len++; } arr[len] = '\0';



### **数组越界问题**

`for (i = 0; i < 80; i++)` 遍历整个数组，但 `gets` 函数只读取一行输入，并用 `\0` 标记结束。因此，当 `arr[i]` 到达未被输入的数据区域时，可能会造成未定义行为。

修正方法： 使用输入的字符串长度作为循环的条件：
#for条件
for里面写的是能进行循环要满足的条件

```c
for (i = 0; arr[i] != '\0'; i++)`
```

"段错误"（Segmentation Fault，简称 "segfault"）是指程序访问了操作系统不允许访问的内存区域
越界,free*2

在C语言中，`fgets()` 和 `scanf()` 都会读取输入缓冲区的数据。当你调用 `fgets()` 读取一行输入时，它会将输入的数据（包括换行符 `\n`）存储在缓冲区中。如果输入的字符串长度小于指定的长度，剩余的部分就会被填充，换行符会保留在缓冲区。

当你接着调用 `scanf("%c")` 时，它会从缓冲区中读取字符。因为换行符还在缓冲区中，所以 `scanf` 会把这个换行符当作输入字符读取，导致意外的行为。这就可能是你遇到段错误或不预期结果的原因。

为了避免这个问题，通常我们会在读取字符之前清空输入缓冲区或者使用适当的输入方式，例如：

- 在 `fgets()` 之后，使用 `getchar()` 来读取并丢弃缓冲区中的换行符，确保下一次输入是新的数据。
- 使用 `scanf(" %c")`（注意前面的空格）来跳过任何前导空白字符，包括换行符。





