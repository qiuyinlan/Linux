# 结构体
## typedef
### 用法:
`typedef`可以为类型定义==别名==，但它并不允许直接在声明时创建实例。`typedef`用于定义类型，但它不能同时用于创建变量或实例。你可以先定义一个结构体类型，然后再创建实例

> 
#### 1. 结构体类型的 `typedef`

通常，`typedef` 后面紧跟着结构体的定义体，然后再给结构体类型命名。

注意大括号前and后
```c
typedef struct {     char kemu[100];     
				int num; 
				} Subject;  // 结构体类型的别名 Subject`
```
此时是匿名的结构体,直接给他来了个别名

或者
```c
```typedef struct Subject {     char kemu[100];     
						   int num; } Subject;  // 结构体类型的别名 Subject
```
这种写法显式命名了结构体名称

#### 2. 不一定需要在大括号后面

你还可以在结构体定义外部定义类型别名，这样可以在结构体定义后使用：

```c
struct Subject {     char kemu[100];     int num; };  typedef struct Subject SubjectAlias;  // 使用 typedef 创建别名
```
这里，`typedef` 并不紧接在结构体定义的后面，而是分开写的。


>   struct Person   person是类型名
    int person   person是变量名

编译器默认变量声明上下文
	为了不冲突,默认单独出现的就是变量名了,加个struct就是类型名
`typedef`为类型创建了别名，把原本属于`struct`命名空间的名字直接放入==普通的类型==命名空间中，从而可以省略`struct`关键字.
使用 `typedef` 后，给结构体起了一个新名字，这个新名字被放入了普通的类型命名空间（即==与 `int`、`float` 等内置类型同属一个空间==），所以不再需要使用 `struct` 来引用它
>struct Person p1; // 声明变量 p1.age = 20
 实例p1作为一个普通变量,可以单独使用

## 结构体访问成员

    通过结构体实例：使用点运算符（.）来访问成员。  
    通过结构体指针：使用箭头运算符（->）来访问成员。
即使在没有显式声明某个结构体实例的情况下，你依然可以通过数组索引访问结构体实例的成员

==->== 运算符是 解引用指针并访问成员 的简写，它结合了 解引用 和 成员访问 两个操作.就是解应用得到原对象再访问

## 结构体交换

```c
Subject temp = s[j]; // Swap the structures s[j] = s[j + 1]; 
s[j + 1] = temp;
```
你使用的交换方法是通过值复制来交换两个结构体变量，所以整个结构体的内容（包括所有成员）都会被交换。

在C语言中，结构体是值传递类型，因此，当你交换结构体时，实际上是在交换结构体的副本

# 数组
## 字符数组

```c
char name[50]; // 定义字符数组，用来存储输入的字符串 printf("Enter your name: "); scanf("%s", name); // 使用 scanf 读取字符串输入 printf("Hello, %s!\n", name); // 输出输入的字符串
```
可以直接使用%s输入和输出,不过要赋值只能用strcpy

### 字符数组输入
其中当然可以有空格,只是scanf识别到空格就停下了,而gets不会停下
可以存空格,但存的媒介要考虑清楚
# case

