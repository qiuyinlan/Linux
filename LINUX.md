io

优先使用标准io,可移植性好

stdio就是标准io的意思

FILE类型[结构体]贯穿始终

当拿来主义

errno要马上打印

### **`fprintf`**:

- 输出目标是一个指定的文件流（可以是文件、`stdout`、`stderr` 等）。
- 用法更灵活，可以向文件或标准错误输出写入

### **`printf`**:

- 输出目标是 **标准输出（stdout）**，通常是屏幕。
- 例如：
    
    ```
    printf("Hello, %s!\n", "Emma");
    ```
    

### **`fflush`**，它是 C 标准库中的函数，用于清空文件流的缓冲区，例如刷新输出流的数据到文件或屏幕

### `man`

是 Linux 的帮助手册命令，用于查看各种命令、函数、系统调用、配置文件等的详细文档。它非常适合查找命令的用法、选项以及函数的说明

`fprintf` 和 `fputs` 都用于输出数据，但有以下区别：

1. **`fputs`**：
    
    - 用于将一个 **字符串** 写入指定的文件或流。
    - 不支持格式化输出，直接写入字符串。
2. **`fprintf`**：
    
    - 用于 **格式化输出**，可以指定格式说明符（如 `%d`, `%s` 等）。
    - 输出到文件或其他流，支持更复杂的输出。

#### 示例：

- `fputs`: `fputs("Hello", stdout);`
- `fprintf`: `fprintf(stdout, "Hello %s", "world");`

`fprintf` 在功能上比 `fputs` 更强大，因为它支持 **格式化输出**，可以按照指定格式数据，适用于更复杂的情况，例如输出整数、浮点数、字符串等。

然而，`fputs` 也有其优势，它更简单和高效，专门用于写入字符串，不需要额外的格式化开销。

因此，是否使用 `fprintf` 取决于你是否需要格式化输出。如果只是写入简单的字符串，`fputs` 更合适；如果需要格式化内容，`fprintf` 更适用。

### fwrite fread

`fwrite` 是专门用于处理二进制数据，而 `fprintf` 和 `fputs` 是用于文本数据的输出

`fread` 是 C 语言中的一个函数，用于从文件中读取二进制数据

### getline

`getline` 是一个用于从文件或标准输入流中读取一整行内容的函数。与 `fgets` 不同，`getline` 会动态分配内存来存储读取的内容，避免了固定缓冲区大小的限制

递归思想

`ls -a -i -l -n` 是一个 Linux 命令，用来列出目录中的文件和文件夹，具有以下选项：

- **`-a`**：列出所有文件，包括以 `.` 开头的隐藏文件。
- **`-i`**：显示每个文件的 inode 号码，inode 是文件的唯一标识符。
- **`-l`**：以长格式列出文件的详细信息，如权限、所有者、文件大小、修改时间等。
- **`-n`**：显示用户和组的 ID 而不是用户名和组名（类似于 `-l`，但显示的是数字 ID）。

### **硬链接 (Hard Link)**

1. **定义**：  
    硬链接是指向文件数据本身的直接链接。多个硬链接共享同一个 inode，因此它们是同一个文件的不同名称。
## 进程
是一个程序的实例
资源分配的单位
线程是程序的具体执行